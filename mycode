class ChooseVariable:
    def __init__(self, number_of_variables):
        self.__n = number_of_variables

    def choose_num_of_variable(self):
        while True:
            n = int(input("Choose a number of variables from 2 to 4: "))
            if 2 <= n <= 4:
                self.__n = n
                break
            else:
                print("Invalid choice, try again.")

    def get_num_of_variables(self):
        return self.__n


class stacks:
    def __init__(self):
        # Hardcoded expression for now
        self.__user = "AV(A^B)"
        self.__var = []
        self.__op = []

    def push(self):
        all_operator = ["(", ")", "V", "^", "¬"]
        all_variables = ["A", "B", "C", "D"]
        expression_in_box = []
        last_push = None
        count = None

        for i, ch in enumerate(self.__user):
            if ch == "(":
                count = i
            elif ch == ")":
                expression_in_box = []
                for z in range(count + 1, i):
                    if self.__user[z] in all_variables:
                        expression_in_box.append(self.__user[z])
                    elif self.__user[z] in all_operator and self.__user[z] not in ["(", ")"]:
                        expression_in_box.append(self.__user[z])
            else:
                if ch in all_variables:
                    self.__var.append(ch)
                    last_push = 'var'
                elif ch in all_operator:
                    self.__op.append(ch)
                    last_push = 'op'

        return expression_in_box, self.__var, self.__op, last_push


def assining_the_values(n):
    # number of variables
    all_variables = ["A", "B", "C", "D"]
    variables = []
    for i in range(n):
        variables.append(all_variables[i])

    # values for respective num of variables
    if n == 2:
        values = [
            (0, 0),
            (0, 1),
            (1, 0),
            (1, 1)
        ]
    elif n == 3:
        values = [
            (0, 0, 0),
            (0, 1, 0),
            (0, 0, 1),
            (0, 1, 1),
            (1, 0, 0),
            (1, 0, 1),
            (1, 1, 0),
            (1, 1, 1)
        ]
    elif n == 4:
        values = [
            (0, 0, 0, 0),
            (0, 0, 0, 1),
            (0, 0, 1, 0),
            (0, 0, 1, 1),
            (0, 1, 0, 0),
            (0, 1, 0, 1),
            (0, 1, 1, 0),
            (0, 1, 1, 1),
            (1, 0, 0, 0),
            (1, 0, 0, 1),
            (1, 0, 1, 0),
            (1, 0, 1, 1),
            (1, 1, 0, 0),
            (1, 1, 0, 1),
            (1, 1, 1, 0),
            (1, 1, 1, 1)
        ]

    dictonary = []
    for row in values:
        each_row = dict(zip(variables, row))
        dictonary.append(each_row)
    return dictonary


class boolean_calculation:
    def __init__(self, all_stack):
        self.__opStacks = all_stack[2]
        self.__varStacks = all_stack[1]
        self.__braStacks = all_stack[0]
        self.__last_item_push = all_stack[3]

    def calculate_bracket(self, dictonary):
        keyboard = {
            "V": lambda a, b: a or b,
            "^": lambda a, b: a and b,
            "¬": lambda a: not a
        }


        bracket_answers = []
        for row in dictonary:
            a = row[self.__braStacks[0]]
            op = self.__braStacks[1]
            b = row[self.__braStacks[2]]
            bracket_answers.append(keyboard[op](a, b))


        outer_results = []
        for i, row in enumerate(dictonary):
            if self.__last_item_push == "var":

                left = row[self.__varStacks[0]]
                op = self.__opStacks[0]
                right = bracket_answers[i]
                result = keyboard[op](left, right)
            else:
                left = bracket_answers[i]
                op = self.__opStacks[0]
                right = row[self.__varStacks[0]]
                result = keyboard[op](left, right)

            outer_results.append(result)

        return outer_results



user = ChooseVariable(2)
user.choose_num_of_variable()
n = user.get_num_of_variables()

dictonary = assining_the_values(n)

userI = stacks()
all_stack = userI.push()
print("Parsed stacks:", all_stack)

userY = boolean_calculation(all_stack)
results = userY.calculate_bracket(dictonary)

print("\nTruth table results:")
for row, res in zip(dictonary, results):
    print(row, "=>", res)
