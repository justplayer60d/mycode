from tkinter import *


class ChooseVariable:
    def __init__(self, number_of_variables):
        self.__n = number_of_variables

    def choose_num_of_variable(self):
        while True:
            n = int(input(
                "Choose a number of variables from 2 to 4: "))  # ask user for the number of variable it wants to use
            if 2 <= n <= 4:
                self.__n = n
                break
            else:
                print("Invalid choice, try again.")  # if user choose a number bigger then 4 or smaller then 2

    def set_num_of_variables(self, n):
        if 2 <= n <= 4:
            self.__n = n
            return True  # validating the number of variables chosen
        return False  # does not validate number that was chosen

    def get_num_of_variables(self):  # returns number of variables user choose
        return self.__n


class stacks:
    def __init__(self, expression):
        # Hardcoded expression for now
        self.__user = expression  # the boolean expression input
        self.__var = []  # the stack for the variables
        self.__op = []  # stack for the operators

    def push(self):
        all_operator = ["(", ")", "V", "^", "¬"]  # the array containing all the operators
        all_variables = ["A", "B", "C", "D"]  # the array containing all the operators
        expression_in_box = []
        last_push = None
        count = None

        for i, ch in enumerate(
                self.__user):  # emuerate funtion loops through the user boolean expression while also keeping an index
            if ch == "(":  # if a bracket in boolean expression is found count will store the index
                count = i
            elif ch == ")":  # checks when ) is found
                expression_in_box = []  # array that stores the expression from the brackets in an array
                for z in range(count + 1, i):  # loop from the first expression in the bracket to the last
                    if self.__user[z] in all_variables:  # checks the list of variables avaliable
                        expression_in_box.append(self.__user[z])
                    elif self.__user[z] in all_operator and self.__user[z] not in ["(", ")"]:
                        # checks the list of available operators and the current character isnt one of the bracket
                        # so not to append the brackets into the array containing the expression
                        expression_in_box.append(self.__user[z])
            else:
                if ch in all_variables:  # if the character is in the list of variables
                    self.__var.append(ch)  # adds variable into a stack for variables
                    last_push = 'var'  # records the last item in the expression is a variable
                elif ch in all_operator:
                    self.__op.append(ch)  # adds operator into a stack for operators
                    last_push = 'op'  # records the last item in the expression is a operator

        return expression_in_box, self.__var, self.__op, last_push
        # returns all stacks and array to be used in the boolean calculation


def assining_the_values(n):  # function for assigning the truth table numbers to each variable
    # number of variables
    all_variables = ["A", "B", "C", "D"]  # list of the variables available
    variables = []
    for i in range(n):
        variables.append(all_variables[i])

    # values for respective num of variables
    if n == 2:
        values = [  # list of all numbers to be used for the truth table combination
            (0, 0),
            (0, 1),
            (1, 0),
            (1, 1)
        ]
    elif n == 3:
        values = [
            (0, 0, 0),
            (0, 1, 0),
            (0, 0, 1),
            (0, 1, 1),
            (1, 0, 0),
            (1, 0, 1),
            (1, 1, 0),
            (1, 1, 1)
        ]
    elif n == 4:
        values = [
            (0, 0, 0, 0),
            (0, 0, 0, 1),
            (0, 0, 1, 0),
            (0, 0, 1, 1),
            (0, 1, 0, 0),
            (0, 1, 0, 1),
            (0, 1, 1, 0),
            (0, 1, 1, 1),
            (1, 0, 0, 0),
            (1, 0, 0, 1),
            (1, 0, 1, 0),
            (1, 0, 1, 1),
            (1, 1, 0, 0),
            (1, 1, 0, 1),
            (1, 1, 1, 0),
            (1, 1, 1, 1)
        ]

    dictonary = []
    for row in values:
        each_row = dict(zip(variables,
                            row))  # zip pairs each item in variables with the corresponding item in row, dict converts those pairs into a dictionary
        dictonary.append(each_row)
    return dictonary


class boolean_calculation:
    def __init__(self, all_stack):  # stack containing the variables and the different combinations
        self.__opStacks = all_stack[2]
        self.__varStacks = all_stack[1]
        self.__braStacks = all_stack[0]
        self.__last_item_push = all_stack[3]

    def calculate_bracket(self, dictonary):
        keyboard = {  # assigns the boolean function to each operator symbol
            "V": lambda a, b: a or b,
            "^": lambda a, b: a and b,
            "¬": lambda a: not a
        }

        # Only calculate bracket if bracket exists
        if len(self.__braStacks) > 0:
            bracket_answers = []  # stores the answer from each boolean calculation
            for row in dictonary:
                a = row[self.__braStacks[0]]
                op = self.__braStacks[1]
                b = row[self.__braStacks[2]]
                bracket_answers.append(keyboard[op](a, b))  # keyboard[op](a, b) carries out the boolean calculation
        else:
            # If no brackets, set bracket_answers to None for each row
            bracket_answers = [None] * len(dictonary)  # Placeholder values

        outer_results = []
        for i, row in enumerate(dictonary):  # Loop through each dictionary in 'dictonary' with its index 'i'
            # Check if there's an outer expression to calculate
            if len(self.__varStacks) > 0 and len(self.__opStacks) > 0 and bracket_answers[i] is not None:
                if self.__last_item_push == "var":
                    left = row[self.__varStacks[0]]  # Get the variable's value from the current row dictionary
                    op = self.__opStacks[0]  # Get the operator from the operator stack
                    right = bracket_answers[i]
                    result = keyboard[op](left, right)  # Apply the operator function to left and right operands
                else:
                    left = bracket_answers[i]
                    op = self.__opStacks[0]
                    right = row[self.__varStacks[0]]
                    result = keyboard[op](left, right)
            # If only brackets, use bracket result
            elif len(self.__braStacks) > 0:
                result = bracket_answers[i]
            # If simple expression like A^B
            elif len(self.__varStacks) >= 2 and len(self.__opStacks) >= 1:
                left = row[self.__varStacks[0]]
                op = self.__opStacks[0]
                right = row[self.__varStacks[1]]
                result = keyboard[op](left, right)
            # If negation like ¬A
            elif len(self.__varStacks) == 1 and len(self.__opStacks) == 1 and self.__opStacks[0] == "¬":
                result = keyboard["¬"](row[self.__varStacks[0]])
            else:
                result = None  # Unsupported format

            outer_results.append(result)

        return outer_results


class Table:
    def __init__(self, root, lst):
        self.cells = []  # Store all Entry widgets in a 2D list to keep track of the table structure

        # Loop through each row in the data
        for i in range(len(lst)):
            row_cells = []  # Create empty list to store Entry widgets for this row

            # Loop through each column in the current row
            for j in range(len(lst[i])):
                # Create an Entry widget (editable text box) for this cell
                e = Entry(
                    root,  # Parent window where this Entry will be placed
                    width=20,  # Width of the text box in characters
                    fg='blue',  # Text color is blue
                    font=('Arial', 16, 'bold')  # Font style, size, and weight
                )
                # Place the Entry widget in a grid at row i, column j
                e.grid(row=i, column=j)
                # Insert the data value into the Entry widget at the end position
                e.insert(END, lst[i][j])
                # Add this Entry widget to the current row's list
                row_cells.append(e)
            # Add the completed row to the main cells list
            self.cells.append(row_cells)
class GUI:
    def __init__(self, window):
        # Store reference to the main window
        self.window = window
        # Set the title that appears at the top of the window
        window.title("Boolean Calculator")

        # Create and display the main heading label
        Label(window, text="Boolean Expression Calculator", font=("Arial", 14, "bold")).pack(pady=10)

        # Label to describe the expression input field
        Label(window, text="Expression:").pack()
        # Entry widget where user types their boolean expression
        self.expression_entry = Entry(window, width=40)
        self.expression_entry.pack()

        # Label to describe the variable selector
        Label(window, text="Number of Variables (2-4):").pack(pady=5)
        # Spinbox widget lets user select number between 2 and 4
        self.var_spinbox = Spinbox(window, from_=2, to=4, width=10)
        self.var_spinbox.pack()

        # Button that runs the calculate method when clicked
        Button(window, text="Calculate", command=self.calculate, bg="green", fg="white").pack(pady=10)

        # Label to describe the results section
        Label(window, text="Results:").pack()
        # Text widget for displaying multi-line truth table results
        self.results_text = Text(window, height=15, width=60)
        self.results_text.pack(pady=10)

    def calculate(self):
        try:
            # Get expression from Entry widget
            expr = self.expression_entry.get()
            # Get number of variables from Spinbox
            n = int(self.var_spinbox.get())

            # Run calculation
            dictonary = assining_the_values(n)
            userI = stacks(expr)
            all_stack = userI.push()
            userY = boolean_calculation(all_stack)
            results = userY.calculate_bracket(dictonary)

            # Build table data
            vars_used = list(dictonary[0].keys())

            # Create header row
            table_data = [vars_used + ['Result']]

            # Add data rows
            for row, res in zip(dictonary, results):
                values = [row[v] for v in vars_used]
                values.append(int(res) if res is not None else 'Error')
                table_data.append(values)

            # Create new window for table
            table_window = Toplevel(self.window)
            table_window.title(f"Truth Table - {expr}")

            # Create table in new window
            t = Table(table_window, table_data)

        except Exception as e:
            # Show error in results text
            self.results_text.delete(1.0, END)
            self.results_text.insert(END, f"Error: {str(e)}")


# Create the window and run the GUI
window = Tk()
app = GUI(window)
window.mainloop()

  

root = tk.Tk() 

root.title("Karnaugh Map")
all_variables = ["A", "B", "C", "D"] 
for row in range(4): 

    for col in range(len(all_variables)): 
        cell = tk.Label(root, text=f"{all_variables[col]}",  

                       borderwidth=1, relief="solid", 

                       width=8, height=3) 

        cell.grid(row=0, column=col, padx=1, pady=1) 
    for i in range(len(all_variables)): 
        cell = tk.Label(root, text=f"{all_variables[row]}",  

                       borderwidth=1, relief="solid", 

                       width=8, height=3) 

        cell.grid(row=row, column=0, padx=1, pady=1) 

  

root.mainloop() 
